Index: include/gazebo_plugins/gazebo_ros_step_world_state.h
===================================================================
--- include/gazebo_plugins/gazebo_ros_step_world_state.h	(revision 34464)
+++ include/gazebo_plugins/gazebo_ros_step_world_state.h	(working copy)
@@ -96,8 +96,8 @@
   /// \brief: parent should be a model
   private: gazebo::Model* parent_model_;
 
-  /// \brief: keep list of all models in the world
-  private: std::vector<gazebo::Model*> models;
+  /// \brief: keep count of all models in the world
+  private: unsigned int model_count;
 
   /// \brief: keep list of all bodies in the world (across models)
   private: std::map<std::string,gazebo::Body*> all_bodies;
Index: include/gazebo_plugins/gazebo_ros_bumper.h
===================================================================
--- include/gazebo_plugins/gazebo_ros_bumper.h	(revision 34464)
+++ include/gazebo_plugins/gazebo_ros_bumper.h	(working copy)
@@ -37,6 +37,7 @@
 #include <gazebo/Controller.hh>
 #include <gazebo/Entity.hh>
 #include <gazebo/Param.hh>
+#include <gazebo/Body.hh>
 
 // ros messages
 #include <ros/ros.h>
Index: src/gazebo_ros_p3d.cpp
===================================================================
--- src/gazebo_ros_p3d.cpp	(revision 34464)
+++ src/gazebo_ros_p3d.cpp	(working copy)
@@ -187,11 +187,10 @@
       // lock in case a model is being spawned
       boost::recursive_mutex::scoped_lock lock(*Simulator::Instance()->GetMRMutex());
       // look through all models in the world, search for body name that matches frameName
-      std::vector<Model*> all_models = World::Instance()->GetModels();
-      for (std::vector<Model*>::iterator iter = all_models.begin(); iter != all_models.end(); iter++)
+      for (unsigned int i = 0; i < World::Instance()->GetModelCount(); i++)
       {
-        //ROS_ERROR("checking model %s for link %s",(*iter)->GetName().c_str(),this->frameName.c_str());
-        if (*iter) this->myFrame = dynamic_cast<Body*>((*iter)->GetBody(this->frameName));
+        gazebo::Model* model = gazebo::World::Instance()->GetModel(i);
+        if (model) this->myFrame = dynamic_cast<Body*>(model->GetBody(this->frameName));
         if (this->myFrame) break;
       }
 
Index: src/gazebo_ros_camera.cpp
===================================================================
--- src/gazebo_ros_camera.cpp	(revision 34464)
+++ src/gazebo_ros_camera.cpp	(working copy)
@@ -211,40 +211,40 @@
   this->myParent->SetActive(false);
 
   // set buffer size
-  this->width            = this->myParent->GetImageWidth();
-  this->height           = this->myParent->GetImageHeight();
-  this->depth            = this->myParent->GetImageDepth();
-  if (this->myParent->GetImageFormat() == "L8")
+  this->width            = this->myParent->GetCamera()->GetImageWidth();
+  this->height           = this->myParent->GetCamera()->GetImageHeight();
+  this->depth            = this->myParent->GetCamera()->GetImageDepth();
+  if (this->myParent->GetCamera()->GetImageFormat() == "L8")
   {
     this->type = sensor_msgs::image_encodings::MONO8;
     this->skip = 1;
   }
-  else if (this->myParent->GetImageFormat() == "R8G8B8")
+  else if (this->myParent->GetCamera()->GetImageFormat() == "R8G8B8")
   {
     this->type = sensor_msgs::image_encodings::RGB8;
     this->skip = 3;
   }
-  else if (this->myParent->GetImageFormat() == "B8G8R8")
+  else if (this->myParent->GetCamera()->GetImageFormat() == "B8G8R8")
   {
     this->type = sensor_msgs::image_encodings::BGR8;
     this->skip = 3;
   }
-  else if (this->myParent->GetImageFormat() == "BAYER_RGGB8")
+  else if (this->myParent->GetCamera()->GetImageFormat() == "BAYER_RGGB8")
   {
     this->type = sensor_msgs::image_encodings::BAYER_RGGB8;
     this->skip = 1;
   }
-  else if (this->myParent->GetImageFormat() == "BAYER_BGGR8")
+  else if (this->myParent->GetCamera()->GetImageFormat() == "BAYER_BGGR8")
   {
     this->type = sensor_msgs::image_encodings::BAYER_BGGR8;
     this->skip = 1;
   }
-  else if (this->myParent->GetImageFormat() == "BAYER_GBRG8")
+  else if (this->myParent->GetCamera()->GetImageFormat() == "BAYER_GBRG8")
   {
     this->type = sensor_msgs::image_encodings::BAYER_GBRG8;
     this->skip = 1;
   }
-  else if (this->myParent->GetImageFormat() == "BAYER_GRBG8")
+  else if (this->myParent->GetCamera()->GetImageFormat() == "BAYER_GRBG8")
   {
     this->type = sensor_msgs::image_encodings::BAYER_GRBG8;
     this->skip = 1;
@@ -264,7 +264,7 @@
   if (this->Cy == 0)
     this->Cy = ((double)this->height+1.0) /2.0;
   if (this->focal_length == 0)
-    this->focal_length = ((double)this->width) / (2.0 *tan(this->myParent->GetHFOV().GetAsRadian()/2.0));
+    this->focal_length = ((double)this->width) / (2.0 *tan(this->myParent->GetCamera()->GetHFOV().GetAsRadian()/2.0));
 
 
 #ifdef USE_CBQ
@@ -324,7 +324,7 @@
   // Get a pointer to image data
   {
     //DIAGNOSTICTIMER(timer("gazebo_ros_camera: GetImageData",6));
-    src = this->myParent->GetImageData(0);
+    src = this->myParent->GetCamera()->GetImageData(0);
   }
 
   if (src)
@@ -352,7 +352,7 @@
 
       // do last minute conversion if Bayer pattern is requested but not provided, go from R8G8B8
       // deprecated in gazebo2 branch, keep for backwards compatibility
-      if (this->myParent->GetImageFormat() == "BAYER_RGGB8" && this->depth == 3)
+      if (this->myParent->GetCamera()->GetImageFormat() == "BAYER_RGGB8" && this->depth == 3)
       {
         for (int i=0;i<this->width;i++)
         {
@@ -377,7 +377,7 @@
         }
         src=dst;
       }
-      else if (this->myParent->GetImageFormat() == "BAYER_BGGR8" && this->depth == 3)
+      else if (this->myParent->GetCamera()->GetImageFormat() == "BAYER_BGGR8" && this->depth == 3)
       {
         for (int i=0;i<this->width;i++)
         {
@@ -402,7 +402,7 @@
         }
         src=dst;
       }
-      else if (this->myParent->GetImageFormat() == "BAYER_GBRG8" && this->depth == 3)
+      else if (this->myParent->GetCamera()->GetImageFormat() == "BAYER_GBRG8" && this->depth == 3)
       {
         for (int i=0;i<this->width;i++)
         {
@@ -427,7 +427,7 @@
         }
         src=dst;
       }
-      else if (this->myParent->GetImageFormat() == "BAYER_GRBG8" && this->depth == 3)
+      else if (this->myParent->GetCamera()->GetImageFormat() == "BAYER_GRBG8" && this->depth == 3)
       {
         for (int i=0;i<this->width;i++)
         {
Index: src/gazebo_ros_bumper.cpp
===================================================================
--- src/gazebo_ros_bumper.cpp	(revision 34464)
+++ src/gazebo_ros_bumper.cpp	(working copy)
@@ -147,10 +147,10 @@
       // lock in case a model is being spawned
       boost::recursive_mutex::scoped_lock lock(*Simulator::Instance()->GetMRMutex());
       // look through all models in the world, search for body name that matches frameName
-      std::vector<Model*> all_models = World::Instance()->GetModels();
-      for (std::vector<Model*>::iterator iter = all_models.begin(); iter != all_models.end(); iter++)
+      for (unsigned int i = 0; i < World::Instance()->GetModelCount(); i++)
       {
-        if (*iter) this->myFrame = dynamic_cast<Body*>((*iter)->GetBody(this->frameName));
+        gazebo::Model* model = gazebo::World::Instance()->GetModel(i);
+        if (model) this->myFrame = dynamic_cast<Body*>(model->GetBody(this->frameName));
         if (this->myFrame) break;
       }
 
Index: src/gazebo_ros_pub_world_state.cpp
===================================================================
--- src/gazebo_ros_pub_world_state.cpp	(revision 34464)
+++ src/gazebo_ros_pub_world_state.cpp	(working copy)
@@ -143,24 +143,20 @@
   Time cur_time = Simulator::Instance()->GetSimTime();
 
   /// \bridf: list of all models in the world
-  std::vector<gazebo::Model*> models;
   std::vector<gazebo::Model*>::iterator miter;
 
   /// \bridf: list of all bodies in the model
   std::map<std::string,gazebo::Body*> all_bodies;
   all_bodies.clear();
 
-  models = gazebo::World::Instance()->GetModels();
-
   // aggregate all bodies into a single vector
-  for (miter = models.begin(); miter != models.end(); miter++)
+  for (unsigned int i = 0; i < World::Instance()->GetModelCount(); i++)
   {
-    const std::vector<gazebo::Entity*> entities = (*miter)->GetChildren();
+    gazebo::Model* model = gazebo::World::Instance()->GetModel(i);
     // Iterate through all bodies
-    std::vector<Entity*>::const_iterator eiter;
-    for (eiter=entities.begin(); eiter!=entities.end(); eiter++)
+    for (unsigned int j = 0; j < model->GetChildCount(); j++)
     {
-      gazebo::Body* body = dynamic_cast<gazebo::Body*>(*eiter);
+      gazebo::Body* body = dynamic_cast<gazebo::Body*>(model->GetChild(j));
       if (body)
         all_bodies.insert(make_pair(body->GetName(),body));
     }
Index: src/gazebo_ros_factory.cpp
===================================================================
--- src/gazebo_ros_factory.cpp	(revision 34464)
+++ src/gazebo_ros_factory.cpp	(working copy)
@@ -139,7 +139,7 @@
   }
 
   // wait and verify that model is deleted
-  while (gazebo::World::Instance()->GetEntityByName(req.model_name))
+  while (gazebo::Common::GetByName(req.model_name))
   {
     ROS_DEBUG("Waiting for model deletion (%s)",req.model_name.c_str());
     usleep(1000);
@@ -159,7 +159,7 @@
 {
   // check to see if model name already exist as a model
   std::string model_name = req.model.model_name;
-  if (gazebo::World::Instance()->GetEntityByName(model_name))
+  if (gazebo::Common::GetByName(model_name))
   {
     ROS_ERROR("model name %s already exist.",model_name.c_str());
     return 0;
@@ -408,7 +408,7 @@
   while (true)
   {
     boost::recursive_mutex::scoped_lock lock(*gazebo::Simulator::Instance()->GetMRMutex());
-    if (gazebo::World::Instance()->GetEntityByName(model_name)) break;
+    if (gazebo::Common::GetByName(model_name)) break;
     ROS_DEBUG("Waiting for spawning model (%s)",model_name.c_str());
     usleep(1000);
   }
Index: src/gazebo_ros_projector.cpp
===================================================================
--- src/gazebo_ros_projector.cpp	(revision 34464)
+++ src/gazebo_ros_projector.cpp	(working copy)
@@ -25,6 +25,7 @@
 #include <gazebo/World.hh>
 #include <gazebo/GazeboError.hh>
 #include <gazebo/ControllerFactory.hh>
+#include <gazebo/Scene.hh>
 
 #include "std_msgs/String.h"
 #include "std_msgs/Int32.h"
@@ -389,7 +390,8 @@
 ////////////////////////////////////////////////////////////////////////////////
 Ogre::SceneManager* GazeboRosProjector::Projector::getSceneMgrP()
 {
-	return OgreAdaptor::Instance()->sceneMgr;
+	//return OgreAdaptor::Instance()->sceneMgr;
+	return OgreAdaptor::Instance()->GetScene(0)->GetManager();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
Index: src/gazebo_ros_sim_iface.cpp
===================================================================
--- src/gazebo_ros_sim_iface.cpp	(revision 34464)
+++ src/gazebo_ros_sim_iface.cpp	(working copy)
@@ -140,7 +140,7 @@
 bool GazeboRosSimIface::ServiceCallback(gazebo_plugins::SetPose::Request &req,
                                         gazebo_plugins::SetPose::Response &res)
 {
-  Model* model = dynamic_cast<Model*>(gazebo::World::Instance()->GetEntityByName(this->modelName));
+  Model* model = dynamic_cast<Model*>(gazebo::Common::GetByName(this->modelName));
   if (model)
   {
     Vector3 target_pos(req.pose.pose.pose.position.x,req.pose.pose.pose.position.y,req.pose.pose.pose.position.z);
@@ -157,10 +157,10 @@
       // lock in case a model is being spawned
       boost::recursive_mutex::scoped_lock lock(*Simulator::Instance()->GetMRMutex());
       // look through all models in the world, search for body name that matches frameName
-      std::vector<Model*> all_models = World::Instance()->GetModels();
-      for (std::vector<Model*>::iterator iter = all_models.begin(); iter != all_models.end(); iter++)
+      for (unsigned int i = 0 ; i < World::Instance()->GetModelCount(); i++)
       {
-        if (*iter) this->myFrame = dynamic_cast<Body*>((*iter)->GetBody(this->frameName));
+        gazebo::Model* model = gazebo::World::Instance()->GetModel(i);
+        if (model) this->myFrame = dynamic_cast<Body*>(model->GetBody(this->frameName));
         if (this->myFrame) break;
       }
 
@@ -224,7 +224,7 @@
 // Update the controller
 void GazeboRosSimIface::UpdateObjectPose(const nav_msgs::Odometry::ConstPtr& poseMsg)
 {
-  Model* model = dynamic_cast<Model*>(gazebo::World::Instance()->GetEntityByName(this->modelName));
+  Model* model = dynamic_cast<Model*>(gazebo::Common::GetByName(this->modelName));
   if (model)
   {
     // target pose
@@ -241,10 +241,9 @@
       // lock in case a model is being spawned
       boost::recursive_mutex::scoped_lock lock(*Simulator::Instance()->GetMRMutex());
       // look through all models in the world, search for body name that matches frameName
-      std::vector<Model*> all_models = World::Instance()->GetModels();
-      for (std::vector<Model*>::iterator iter = all_models.begin(); iter != all_models.end(); iter++)
+      for (unsigned int i = 0; i < World::Instance()->GetModelCount(); i++)
       {
-        if (*iter) this->myFrame = dynamic_cast<Body*>((*iter)->GetBody(this->frameName));
+        if (model) this->myFrame = dynamic_cast<Body*>(model->GetBody(this->frameName));
         if (this->myFrame) break;
       }
 
Index: src/gazebo_ros_step_world_state.cpp
===================================================================
--- src/gazebo_ros_step_world_state.cpp	(revision 34464)
+++ src/gazebo_ros_step_world_state.cpp	(working copy)
@@ -61,7 +61,7 @@
   Param::End();
 
   this->all_bodies.clear();
-  this->models.clear();
+  this->model_count = 0;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -164,20 +164,19 @@
 
   // FIXME: this test simply checks the number of models for now, better
   //        to setup a flag to indicate whether models in the world have changed
-  if (this->models.size() != gazebo::World::Instance()->GetModels().size())
+  if (this->model_count != gazebo::World::Instance()->GetModelCount())
   {
-    this->models = gazebo::World::Instance()->GetModels();
+    this->model_count = gazebo::World::Instance()->GetModelCount();
 
     // aggregate all bodies into a single vector
-    for (std::vector<gazebo::Model*>::iterator miter = this->models.begin(); miter != this->models.end(); miter++)
+    for (unsigned int i = 0; i < this->model_count; i++)
     {
+      gazebo::Model* model = gazebo::World::Instance()->GetModel(i);
       // list of all bodies in the current model
-      const std::vector<gazebo::Entity*> entities = (*miter)->GetChildren();
       // Iterate through all bodies
-      std::vector<Entity*>::const_iterator eiter;
-      for (eiter=entities.begin(); eiter!=entities.end(); eiter++)
+      for (unsigned int j = 0; j < model->GetChildCount(); j++)
       {
-        gazebo::Body* body = dynamic_cast<gazebo::Body*>(*eiter);
+        gazebo::Body* body = dynamic_cast<gazebo::Body*>(model->GetChild(j));
         if (body)
           this->all_bodies.insert(make_pair(body->GetName(),body));
       }
